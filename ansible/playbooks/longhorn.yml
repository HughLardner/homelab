---
# Longhorn Storage Installation Playbook
# Installs Longhorn distributed block storage for persistent volumes
#
# Prerequisites:
#   - K3s cluster running
#   - kubectl configured
#
# Optional: For IngressRoute/TLS access:
#   - Traefik installed (for ingress)
#   - cert-manager installed (for TLS certificates)
#
# Usage:
#   ansible-playbook playbooks/longhorn.yml
#
# Variables:
#   Required:
#     None - will install with defaults
#
#   Optional (for IngressRoute):
#     - longhorn_domain: Domain for Longhorn UI (e.g., longhorn.example.com)
#     - longhorn_cert_issuer: Cert-manager issuer (default: letsencrypt-staging)
#
# Example with IngressRoute:
#   ansible-playbook playbooks/longhorn.yml -e "longhorn_domain=longhorn.silverseekers.org" -e "longhorn_cert_issuer=letsencrypt-prod"

- name: Install Longhorn Storage
  hosts: k3s_masters[0]
  become: true
  gather_facts: true

  vars_files:
    - "{{ playbook_dir }}/../../config/homelab.yaml"

  vars:
    longhorn_version: "v1.6.0"
    longhorn_namespace: "longhorn-system"
    longhorn_manifests_path: "{{ playbook_dir }}/../../kubernetes/services/longhorn"
    # Variables loaded from config/homelab.yaml via vars_files
    longhorn_domain: "{{ services.longhorn.domain }}"
    longhorn_cert_issuer: "{{ services.longhorn.cert_issuer | default(global.cert_issuer) }}"
    longhorn_replica_count: "{{ services.longhorn.replica_count | default(1) }}"
    longhorn_data_path: "{{ services.longhorn.data_path | default('/var/lib/longhorn') }}"
    longhorn_ui_service_type: "{{ services.longhorn.ui_service_type | default('LoadBalancer') }}"

  pre_tasks:
    - name: Wait for K3s to be ready
      ansible.builtin.command: /usr/local/bin/k3s kubectl get nodes
      register: k3s_status
      changed_when: false
      retries: 10
      delay: 5
      until: k3s_status.rc == 0

    - name: Check if IngressRoute will be configured
      ansible.builtin.set_fact:
        configure_ingress: "{{ longhorn_domain is defined and longhorn_domain | length > 0 }}"

    - name: Display IngressRoute configuration status
      ansible.builtin.debug:
        msg: "{{ 'Will configure IngressRoute for domain: ' + longhorn_domain if configure_ingress else 'Skipping IngressRoute configuration (no longhorn_domain provided)' }}"

    - name: Check node storage availability
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes -o json | \
        jq -r '.items[] | "\(.metadata.name): \(.status.allocatable.storage // "unknown")"'
      register: node_storage
      changed_when: false

    - name: Display storage availability
      ansible.builtin.debug:
        msg: "{{ node_storage.stdout_lines }}"

  tasks:
    - name: Create Longhorn namespace
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl create namespace {{ longhorn_namespace }}
      register: namespace_result
      changed_when: "'created' in namespace_result.stdout"
      failed_when: false

    - name: Check if Longhorn is already installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get deployment -n {{ longhorn_namespace }} longhorn-driver-deployer
      register: longhorn_check
      changed_when: false
      failed_when: false

    - name: Install Longhorn prerequisites
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/{{ longhorn_version }}/deploy/prerequisite/longhorn-iscsi-installation.yaml
      when: longhorn_check.rc != 0
      register: prereq_install
      changed_when: "'created' in prereq_install.stdout or 'configured' in prereq_install.stdout"

    - name: Wait for prerequisites to be installed
      ansible.builtin.pause:
        seconds: 10
      when: longhorn_check.rc != 0

    - name: Install Longhorn
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/{{ longhorn_version }}/deploy/longhorn.yaml
      when: longhorn_check.rc != 0
      register: longhorn_install
      changed_when: "'created' in longhorn_install.stdout or 'configured' in longhorn_install.stdout"

    - name: Wait for Longhorn manager to be ready
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl wait --namespace {{ longhorn_namespace }} --for=condition=ready pod --selector=app=longhorn-manager --timeout=600s
      register: manager_wait
      changed_when: false
      retries: 3
      delay: 10
      until: manager_wait.rc == 0

    - name: Wait for Longhorn driver deployer to be ready
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl wait --namespace {{ longhorn_namespace }} --for=condition=ready pod --selector=app=longhorn-driver-deployer --timeout=300s
      register: driver_wait
      changed_when: false
      retries: 3
      delay: 10
      until: driver_wait.rc == 0

    - name: Patch Longhorn frontend service to LoadBalancer
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl patch svc longhorn-frontend -n {{ longhorn_namespace }} -p '{"spec":{"type":"{{ longhorn_ui_service_type }}"}}'
      register: patch_result
      changed_when: "'patched' in patch_result.stdout or 'no change' not in patch_result.stderr"
      failed_when: false

    - name: Wait for LoadBalancer IP (if LoadBalancer type)
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get svc -n {{ longhorn_namespace }} longhorn-frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
      register: longhorn_lb_ip
      changed_when: false
      retries: 30
      delay: 5
      until: longhorn_lb_ip.stdout != ""
      when: longhorn_ui_service_type == "LoadBalancer"
      failed_when: false

    - name: Configure Longhorn default settings
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch settings.longhorn.io -n {{ longhorn_namespace }} default-replica-count \
          --type=merge -p '{"value":"{{ longhorn_replica_count }}"}'
      register: replica_config
      changed_when: "'patched' in replica_config.stdout"
      failed_when: false

    - name: Verify Longhorn pods are running
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get pods -n {{ longhorn_namespace }} --no-headers
      register: longhorn_status
      changed_when: false
      failed_when: "'Running' not in longhorn_status.stdout"

    - name: Verify StorageClass exists
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get storageclass longhorn
      register: sc_check
      changed_when: false
      failed_when: sc_check.rc != 0

    # =========================================================================
    # IngressRoute Configuration (Optional)
    # =========================================================================
    - name: Check if Traefik IngressRoute CRD is installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get crd ingressroutes.traefik.io
      register: traefik_crd_check
      changed_when: false
      failed_when: false
      when: configure_ingress | bool

    - name: Check if cert-manager Certificate CRD is installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get crd certificates.cert-manager.io
      register: certmanager_crd_check
      changed_when: false
      failed_when: false
      when: configure_ingress | bool

    - name: Set CRD availability fact
      ansible.builtin.set_fact:
        crds_available: "{{ traefik_crd_check.rc == 0 and certmanager_crd_check.rc == 0 }}"
      when: configure_ingress | bool

    - name: Skip IngressRoute if CRDs not available
      ansible.builtin.debug:
        msg: |
          ‚è≠Ô∏è  Skipping IngressRoute configuration - required CRDs not yet installed.
          Traefik CRD: {{ 'available' if traefik_crd_check.rc == 0 else 'NOT FOUND' }}
          cert-manager CRD: {{ 'available' if certmanager_crd_check.rc == 0 else 'NOT FOUND' }}
          Run 'make longhorn-ingress' after installing Traefik and cert-manager to configure IngressRoute.
      when: configure_ingress | bool and not (crds_available | default(false))

    - name: Create temporary directory for templated manifests
      ansible.builtin.tempfile:
        state: directory
        prefix: longhorn_
      register: temp_dir
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Template IngressRoute manifests
      ansible.builtin.template:
        src: "{{ longhorn_manifests_path }}/ingressroute.yaml"
        dest: "{{ temp_dir.path }}/ingressroute.yaml"
        mode: "0644"
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Apply IngressRoute for Longhorn
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl apply -f {{ temp_dir.path }}/ingressroute.yaml
      register: ingressroute_result
      changed_when: "'created' in ingressroute_result.stdout or 'configured' in ingressroute_result.stdout"
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Get IngressRoute status
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get ingressroute -n {{ longhorn_namespace }}
      register: longhorn_ingressroute
      changed_when: false
      failed_when: false
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Get certificate status
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get certificate -n {{ longhorn_namespace }}
      register: longhorn_cert
      changed_when: false
      failed_when: false
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Clean up temporary directory
      ansible.builtin.file:
        path: "{{ temp_dir.path }}"
        state: absent
      when: configure_ingress | bool and (crds_available | default(false)) and temp_dir.path is defined

  post_tasks:
    - name: Get Longhorn UI access information
      ansible.builtin.set_fact:
        ui_access: >-
          {%- if configure_ingress | default(false) and crds_available | default(false) and longhorn_domain is defined -%}
          https://{{ longhorn_domain }}
          {%- elif longhorn_ui_service_type == 'LoadBalancer' and longhorn_lb_ip.stdout | default('') != '' -%}
          http://{{ longhorn_lb_ip.stdout }}
          {%- elif longhorn_ui_service_type == 'NodePort' -%}
          http://<node-ip>:<node-port>
          {%- else -%}
          kubectl port-forward -n {{ longhorn_namespace }} svc/longhorn-frontend 8080:80
          {%- endif -%}

    - name: Build completion message
      ansible.builtin.set_fact:
        completion_message: |

          ========================================
          ‚úÖ Longhorn Installation Complete!
          ========================================

          Configuration:
            Namespace: {{ longhorn_namespace }}
            Version: {{ longhorn_version }}
            Replica Count: {{ longhorn_replica_count }}
            Data Path: {{ longhorn_data_path }}
            UI Service Type: {{ longhorn_ui_service_type }}

          Access Longhorn UI:
            {{ ui_access }}

          StorageClass:
            Name: longhorn (default)
            Provisioner: driver.longhorn.io

          {%- if configure_ingress | default(false) and crds_available | default(false) %}

          üåê IngressRoute:
          {{ longhorn_ingressroute.stdout | default('Not configured') }}

          üîê Certificate:
          {{ longhorn_cert.stdout | default('Not found - check cert-manager') }}
          {%- elif configure_ingress | default(false) and not crds_available | default(false) %}

          ‚è≠Ô∏è  IngressRoute: SKIPPED (Traefik/cert-manager CRDs not yet installed)
          Run 'make longhorn-ingress' after Traefik and cert-manager are deployed.
          {%- endif %}

          Verify Installation:
            kubectl get pods -n {{ longhorn_namespace }}
            kubectl get storageclass
            kubectl get pv
            {%- if configure_ingress | default(false) and crds_available | default(false) %}
            kubectl get ingressroute -n {{ longhorn_namespace }}
            kubectl get certificate -n {{ longhorn_namespace }}
            {%- endif %}

          ========================================

    - name: Display completion message
      ansible.builtin.debug:
        msg: "{{ completion_message.split('\n') }}"
