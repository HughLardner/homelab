---
# Longhorn Storage Installation Playbook
# Installs Longhorn distributed block storage for persistent volumes
#
# Prerequisites:
#   - K3s cluster running
#   - kubectl configured
#
# Optional: For IngressRoute/TLS access:
#   - Traefik installed (for ingress)
#   - cert-manager installed (for TLS certificates)
#
# Usage:
#   ansible-playbook playbooks/longhorn.yml
#
# Variables:
#   Required:
#     None - will install with defaults
#
#   Optional (for IngressRoute):
#     - longhorn_domain: Domain for Longhorn UI (e.g., longhorn.example.com)
#     - longhorn_cert_issuer: Cert-manager issuer (default: letsencrypt-staging)
#
# Example with IngressRoute:
#   ansible-playbook playbooks/longhorn.yml -e "longhorn_domain=longhorn.silverseekers.org" -e "longhorn_cert_issuer=letsencrypt-prod"

- name: Install Longhorn Storage
  hosts: k3s_masters[0]
  become: true
  gather_facts: true

  vars_files:
    - "{{ playbook_dir }}/../../config/homelab.yaml"

  vars:
    longhorn_version: "v1.6.0"
    longhorn_namespace: "longhorn-system"
    longhorn_manifests_path: "{{ playbook_dir }}/../../kubernetes/services/longhorn"
    # Variables loaded from config/homelab.yaml via vars_files
    longhorn_domain: "{{ services.longhorn.domain }}"
    longhorn_cert_issuer: "{{ services.longhorn.cert_issuer | default(global.cert_issuer) }}"
    longhorn_replica_count: "{{ services.longhorn.replica_count | default(1) }}"
    longhorn_data_path: "{{ services.longhorn.data_path | default('/var/lib/longhorn') }}"
    longhorn_ui_service_type: "{{ services.longhorn.ui_service_type | default('LoadBalancer') }}"

  pre_tasks:
    - name: Wait for K3s to be ready
      ansible.builtin.command: /usr/local/bin/k3s kubectl get nodes
      register: k3s_status
      changed_when: false
      retries: 10
      delay: 5
      until: k3s_status.rc == 0

    - name: Check if IngressRoute will be configured
      ansible.builtin.set_fact:
        configure_ingress: "{{ longhorn_domain is defined and longhorn_domain | length > 0 }}"

    - name: Display IngressRoute configuration status
      ansible.builtin.debug:
        msg: "{{ 'Will configure IngressRoute for domain: ' + longhorn_domain if configure_ingress else 'Skipping IngressRoute configuration (no longhorn_domain provided)' }}"

    - name: Check node storage availability
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes -o json | \
        jq -r '.items[] | "\(.metadata.name): \(.status.allocatable.storage // "unknown")"'
      register: node_storage
      changed_when: false

    - name: Display storage availability
      ansible.builtin.debug:
        msg: "{{ node_storage.stdout_lines }}"

    # =========================================================================
    # Configure nodes for persistent disk ONLY (prevent OS disk usage)
    # =========================================================================
    - name: Get all node names
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes -o jsonpath='{.items[*].metadata.name}'
      register: node_names
      changed_when: false

    - name: Label nodes for Longhorn disk config
      ansible.builtin.command:
        cmd: >
          /usr/local/bin/k3s kubectl label node {{ item }}
          node.longhorn.io/create-default-disk=config
          --overwrite
      loop: "{{ node_names.stdout.split() }}"
      register: label_result
      changed_when: "'labeled' in label_result.stdout or 'not labeled' not in label_result.stderr"

    - name: Annotate nodes with persistent disk config
      ansible.builtin.command:
        cmd: >
          /usr/local/bin/k3s kubectl annotate node {{ item }}
          node.longhorn.io/default-disks-config='[{"path":"{{ longhorn_data_path }}","allowScheduling":true,"storageReserved":0,"tags":["persistent"]}]'
          --overwrite
      loop: "{{ node_names.stdout.split() }}"
      register: annotate_result
      changed_when: "'annotated' in annotate_result.stdout or 'not annotated' not in annotate_result.stderr"

    - name: Display node configuration status
      ansible.builtin.debug:
        msg:
          - "‚úÖ Nodes configured for persistent storage only"
          - "Label: node.longhorn.io/create-default-disk=config"
          - "Disk Path: {{ longhorn_data_path }}"
          - "‚ö†Ô∏è  Longhorn will ONLY use {{ longhorn_data_path }} - OS disk is excluded"

  tasks:
    - name: Create Longhorn namespace
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl create namespace {{ longhorn_namespace }}
      register: namespace_result
      changed_when: "'created' in namespace_result.stdout"
      failed_when: false

    - name: Check if Longhorn is already installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get deployment -n {{ longhorn_namespace }} longhorn-driver-deployer
      register: longhorn_check
      changed_when: false
      failed_when: false

    - name: Install Longhorn prerequisites
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/{{ longhorn_version }}/deploy/prerequisite/longhorn-iscsi-installation.yaml
      when: longhorn_check.rc != 0
      register: prereq_install
      changed_when: "'created' in prereq_install.stdout or 'configured' in prereq_install.stdout"

    - name: Wait for prerequisites to be installed
      ansible.builtin.pause:
        seconds: 10
      when: longhorn_check.rc != 0

    - name: Install Longhorn
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/{{ longhorn_version }}/deploy/longhorn.yaml
      when: longhorn_check.rc != 0
      register: longhorn_install
      changed_when: "'created' in longhorn_install.stdout or 'configured' in longhorn_install.stdout"

    - name: Wait for Longhorn manager to be ready
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl wait --namespace {{ longhorn_namespace }} --for=condition=ready pod --selector=app=longhorn-manager --timeout=600s
      register: manager_wait
      changed_when: false
      retries: 3
      delay: 10
      until: manager_wait.rc == 0

    - name: Wait for Longhorn driver deployer to be ready
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl wait --namespace {{ longhorn_namespace }} --for=condition=ready pod --selector=app=longhorn-driver-deployer --timeout=300s
      register: driver_wait
      changed_when: false
      retries: 3
      delay: 10
      until: driver_wait.rc == 0

    - name: Patch Longhorn frontend service to LoadBalancer
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl patch svc longhorn-frontend -n {{ longhorn_namespace }} -p '{"spec":{"type":"{{ longhorn_ui_service_type }}"}}'
      register: patch_result
      changed_when: "'patched' in patch_result.stdout or 'no change' not in patch_result.stderr"
      failed_when: false

    - name: Wait for LoadBalancer IP (if LoadBalancer type)
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get svc -n {{ longhorn_namespace }} longhorn-frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
      register: longhorn_lb_ip
      changed_when: false
      retries: 30
      delay: 5
      until: longhorn_lb_ip.stdout != ""
      when: longhorn_ui_service_type == "LoadBalancer"
      failed_when: false

    - name: Configure Longhorn default settings
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch settings.longhorn.io -n {{ longhorn_namespace }} default-replica-count \
          --type=merge -p '{"value":"{{ longhorn_replica_count }}"}'
      register: replica_config
      changed_when: "'patched' in replica_config.stdout"
      failed_when: false

    - name: Configure Longhorn to only use labeled nodes for disk creation
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch settings.longhorn.io -n {{ longhorn_namespace }} create-default-disk-labeled-nodes \
          --type=merge -p '{"value":"true"}'
      register: labeled_nodes_config
      changed_when: "'patched' in labeled_nodes_config.stdout"
      failed_when: false

    - name: Configure Longhorn default data path
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch settings.longhorn.io -n {{ longhorn_namespace }} default-data-path \
          --type=merge -p '{"value":"{{ longhorn_data_path }}"}'
      register: data_path_config
      changed_when: "'patched' in data_path_config.stdout"
      failed_when: false

    # =========================================================================
    # Add persistent disk to Longhorn nodes
    # The annotations configure what SHOULD happen, but we need to explicitly
    # add the disk after Longhorn starts to ensure it's registered
    # =========================================================================
    - name: Wait for Longhorn nodes to be registered
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes.longhorn.io -n {{ longhorn_namespace }} -o jsonpath='{.items[*].metadata.name}'
      register: longhorn_nodes
      changed_when: false
      retries: 30
      delay: 5
      until: longhorn_nodes.stdout | length > 0

    - name: Check if persistent disk exists on nodes
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes.longhorn.io -n {{ longhorn_namespace }} {{ item }} \
          -o jsonpath='{.spec.disks}' | jq -r 'to_entries[] | select(.value.path == "{{ longhorn_data_path }}") | .key'
      loop: "{{ longhorn_nodes.stdout.split() }}"
      register: persistent_disk_check
      changed_when: false
      failed_when: false

    - name: Add persistent disk to Longhorn nodes
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch nodes.longhorn.io -n {{ longhorn_namespace }} {{ item.item }} \
          --type=merge -p '{
            "spec": {
              "disks": {
                "persistent-data": {
                  "path": "{{ longhorn_data_path }}",
                  "allowScheduling": true,
                  "diskType": "filesystem",
                  "evictionRequested": false,
                  "storageReserved": 10737418240,
                  "tags": []
                }
              }
            }
          }'
      loop: "{{ persistent_disk_check.results }}"
      when: item.stdout == ""
      register: add_disk
      changed_when: "'patched' in add_disk.stdout"
      failed_when: false

    # =========================================================================
    # Disable any disks NOT on the persistent storage path (existing installs)
    # =========================================================================
    - name: Get Longhorn node disk configuration
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get nodes.longhorn.io -n {{ longhorn_namespace }} -o json | \
        jq -r '.items[] | select(.spec.disks != null) | {name: .metadata.name, disks: [.spec.disks | to_entries[] | select(.value.path != "{{ longhorn_data_path }}") | .key]} | select(.disks | length > 0) | "\(.name):\(.disks | join(","))"'
      register: unwanted_disks
      changed_when: false
      failed_when: false

    - name: Report unwanted disks found
      ansible.builtin.debug:
        msg:
          - "‚ö†Ô∏è  Found disks NOT on persistent storage path!"
          - "Disks to disable: {{ unwanted_disks.stdout_lines }}"
          - "These disks are on the ephemeral OS disk and data will NOT survive rebuilds"
          - "Please disable these disks in Longhorn UI: Node ‚Üí Select Node ‚Üí Edit Disks ‚Üí Disable unwanted disk"
      when: unwanted_disks.stdout | length > 0

    - name: Disable unwanted disks on nodes (scheduling only)
      ansible.builtin.shell: |
        NODE_NAME=$(echo "{{ item }}" | cut -d: -f1)
        DISK_NAMES=$(echo "{{ item }}" | cut -d: -f2)
        for DISK in $(echo $DISK_NAMES | tr ',' ' '); do
          echo "Disabling scheduling for disk $DISK on node $NODE_NAME"
          /usr/local/bin/k3s kubectl patch nodes.longhorn.io -n {{ longhorn_namespace }} $NODE_NAME \
            --type=json -p="[{\"op\": \"replace\", \"path\": \"/spec/disks/$DISK/allowScheduling\", \"value\": false}]" || true
        done
      loop: "{{ unwanted_disks.stdout_lines }}"
      when: unwanted_disks.stdout | length > 0
      register: disable_result
      changed_when: true
      failed_when: false

    - name: Verify Longhorn pods are running
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get pods -n {{ longhorn_namespace }} --no-headers
      register: longhorn_status
      changed_when: false
      failed_when: "'Running' not in longhorn_status.stdout"

    - name: Verify StorageClass exists
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get storageclass longhorn
      register: sc_check
      changed_when: false
      failed_when: sc_check.rc != 0

    # =========================================================================
    # Fix StorageClass replica count (Longhorn creates with 3 replicas by default)
    # Longhorn reconciles StorageClass from ConfigMap longhorn-storageclass
    # =========================================================================
    - name: Get current StorageClass replica count
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get sc longhorn -o jsonpath='{.parameters.numberOfReplicas}'
      register: current_sc_replicas
      changed_when: false
      failed_when: false

    - name: Patch StorageClass ConfigMap with correct replica count
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl patch configmap -n {{ longhorn_namespace }} longhorn-storageclass --type='json' -p='[
          {
            "op": "replace",
            "path": "/data/storageclass.yaml",
            "value": "kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: longhorn\n  annotations:\n    storageclass.kubernetes.io/is-default-class: \"false\"\nprovisioner: driver.longhorn.io\nallowVolumeExpansion: true\nreclaimPolicy: \"Delete\"\nvolumeBindingMode: Immediate\nparameters:\n  numberOfReplicas: \"{{ longhorn_replica_count }}\"\n  staleReplicaTimeout: \"30\"\n  fromBackup: \"\"\n  fsType: \"ext4\"\n  dataLocality: \"disabled\"\n"
          }
        ]'
      when: current_sc_replicas.stdout != longhorn_replica_count | string
      register: cm_patch
      changed_when: "'patched' in cm_patch.stdout"

    - name: Delete StorageClass to trigger recreation from ConfigMap
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl delete sc longhorn --ignore-not-found
      when: current_sc_replicas.stdout != longhorn_replica_count | string
      register: sc_delete
      changed_when: "'deleted' in sc_delete.stdout"

    - name: Wait for StorageClass to be recreated
      ansible.builtin.pause:
        seconds: 5
      when: current_sc_replicas.stdout != longhorn_replica_count | string

    - name: Verify StorageClass has correct replica count
      ansible.builtin.shell: |
        /usr/local/bin/k3s kubectl get sc longhorn -o jsonpath='{.parameters.numberOfReplicas}'
      register: verify_sc_replicas
      changed_when: false
      failed_when: verify_sc_replicas.stdout != longhorn_replica_count | string

    # =========================================================================
    # IngressRoute Configuration (Optional)
    # =========================================================================
    - name: Check if Traefik IngressRoute CRD is installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get crd ingressroutes.traefik.io
      register: traefik_crd_check
      changed_when: false
      failed_when: false
      when: configure_ingress | bool

    - name: Check if cert-manager Certificate CRD is installed
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get crd certificates.cert-manager.io
      register: certmanager_crd_check
      changed_when: false
      failed_when: false
      when: configure_ingress | bool

    - name: Set CRD availability fact
      ansible.builtin.set_fact:
        crds_available: "{{ traefik_crd_check.rc == 0 and certmanager_crd_check.rc == 0 }}"
      when: configure_ingress | bool

    - name: Skip IngressRoute if CRDs not available
      ansible.builtin.debug:
        msg: |
          ‚è≠Ô∏è  Skipping IngressRoute configuration - required CRDs not yet installed.
          Traefik CRD: {{ 'available' if traefik_crd_check.rc == 0 else 'NOT FOUND' }}
          cert-manager CRD: {{ 'available' if certmanager_crd_check.rc == 0 else 'NOT FOUND' }}
          Run 'make longhorn-ingress' after installing Traefik and cert-manager to configure IngressRoute.
      when: configure_ingress | bool and not (crds_available | default(false))

    - name: Deploy Longhorn Ingress via Helm
      ansible.builtin.command:
        cmd: >
          helm upgrade --install longhorn-ingress
          {{ longhorn_manifests_path }}
          --namespace {{ longhorn_namespace }}
          --values {{ playbook_dir }}/../../config/homelab.yaml
          --wait
          --timeout=5m
      environment:
        KUBECONFIG: "{{ lookup('env', 'HOME') }}/.kube/config-homelab"
      delegate_to: localhost
      become: false
      when: configure_ingress | bool and (crds_available | default(false))
      register: helm_result
      changed_when: "'has been upgraded' in helm_result.stdout or 'has been installed' in helm_result.stdout"

    - name: Get IngressRoute status
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get ingressroute -n {{ longhorn_namespace }}
      register: longhorn_ingressroute
      changed_when: false
      failed_when: false
      when: configure_ingress | bool and (crds_available | default(false))

    - name: Get certificate status
      ansible.builtin.command:
        cmd: /usr/local/bin/k3s kubectl get certificate -n {{ longhorn_namespace }}
      register: longhorn_cert
      changed_when: false
      failed_when: false
      when: configure_ingress | bool and (crds_available | default(false))

  post_tasks:
    - name: Get Longhorn UI access information
      ansible.builtin.set_fact:
        ui_access: >-
          {%- if configure_ingress | default(false) and crds_available | default(false) and longhorn_domain is defined -%}
          https://{{ longhorn_domain }}
          {%- elif longhorn_ui_service_type == 'LoadBalancer' and longhorn_lb_ip.stdout | default('') != '' -%}
          http://{{ longhorn_lb_ip.stdout }}
          {%- elif longhorn_ui_service_type == 'NodePort' -%}
          http://<node-ip>:<node-port>
          {%- else -%}
          kubectl port-forward -n {{ longhorn_namespace }} svc/longhorn-frontend 8080:80
          {%- endif -%}

    - name: Build completion message
      ansible.builtin.set_fact:
        completion_message: |

          ========================================
          ‚úÖ Longhorn Installation Complete!
          ========================================

          Configuration:
            Namespace: {{ longhorn_namespace }}
            Version: {{ longhorn_version }}
            Replica Count: {{ longhorn_replica_count }}
            Data Path: {{ longhorn_data_path }}
            UI Service Type: {{ longhorn_ui_service_type }}

          üîí Persistent Storage Protection:
            - createDefaultDiskLabeledNodes: ENABLED
            - Only using disk at: {{ longhorn_data_path }}
            - OS disk excluded (ephemeral, does not survive rebuilds)
            {%- if unwanted_disks.stdout | default('') | length > 0 %}
            - ‚ö†Ô∏è  Disabled scheduling on OS disk(s): {{ unwanted_disks.stdout_lines | join(', ') }}
            {%- endif %}

          Access Longhorn UI:
            {{ ui_access }}

          StorageClass:
            Name: longhorn (default)
            Provisioner: driver.longhorn.io

          {%- if configure_ingress | default(false) and crds_available | default(false) %}

          üåê IngressRoute:
          {{ longhorn_ingressroute.stdout | default('Not configured') }}

          üîê Certificate:
          {{ longhorn_cert.stdout | default('Not found - check cert-manager') }}
          {%- elif configure_ingress | default(false) and not crds_available | default(false) %}

          ‚è≠Ô∏è  IngressRoute: SKIPPED (Traefik/cert-manager CRDs not yet installed)
          Run 'make longhorn-ingress' after Traefik and cert-manager are deployed.
          {%- endif %}

          Verify Installation:
            kubectl get pods -n {{ longhorn_namespace }}
            kubectl get storageclass
            kubectl get pv
            {%- if configure_ingress | default(false) and crds_available | default(false) %}
            kubectl get ingressroute -n {{ longhorn_namespace }}
            kubectl get certificate -n {{ longhorn_namespace }}
            {%- endif %}

          ========================================

    - name: Display completion message
      ansible.builtin.debug:
        msg: "{{ completion_message.split('\n') }}"
