---
# Secrets Configuration Template
#
# INSTRUCTIONS:
# 1. Copy this file to config/secrets.yml
# 2. Fill in your actual secret values
# 3. Run: make seal-secrets
# 4. The playbook will encrypt and commit the sealed secrets to git
#
# IMPORTANT: config/secrets.yml is gitignored and should NEVER be committed!
#
# See also: config/homelab.yaml for non-secret configuration

# =============================================================================
# Ansible Playbook Secrets
# =============================================================================
# These are used directly by Ansible playbooks (not sealed secrets)

# Cloudflare API token for DNS challenges (cert-manager)
# Get from: https://dash.cloudflare.com/profile/api-tokens
cloudflare_api_token: "YOUR_CLOUDFLARE_API_TOKEN"

# Traefik dashboard password (will be hashed with htpasswd)
traefik_dashboard_password: "changeme123"

# ArgoCD admin password
argocd_password: "changeme123"

# Grafana admin password
grafana_admin_password: "changeme123"

# GitHub token for ArgoCD repository access (optional)
# Only needed for private repos
github_token: ""

# =============================================================================
# Kubernetes Sealed Secrets
# =============================================================================
# These are encrypted with kubeseal and committed to git

secrets:
  # Example 1: Grafana admin credentials
  - name: grafana-admin-secret
    namespace: monitoring
    type: Opaque
    scope: strict  # Options: strict (default), namespace-wide, cluster-wide
    output_path: kubernetes/applications/monitoring/secrets/grafana-admin-sealed.yaml
    data:
      admin-user: admin
      admin-password: changeme123

  # Example 2: Database credentials
  # - name: postgres-creds
  #   namespace: default
  #   type: Opaque
  #   scope: strict
  #   output_path: kubernetes/applications/myapp/secrets/postgres-creds-sealed.yaml
  #   data:
  #     username: postgres
  #     password: secure-database-password
  #     database: myapp
  #     host: postgres.default.svc.cluster.local
  #     port: "5432"

  # Example 3: TLS certificate (from files)
  # - name: my-tls-cert
  #   namespace: default
  #   type: kubernetes.io/tls
  #   scope: strict
  #   output_path: kubernetes/applications/myapp/secrets/tls-cert-sealed.yaml
  #   data:
  #     tls.crt: |
  #       -----BEGIN CERTIFICATE-----
  #       ... certificate content ...
  #       -----END CERTIFICATE-----
  #     tls.key: |
  #       -----BEGIN PRIVATE KEY-----
  #       ... private key content ...
  #       -----END PRIVATE KEY-----

  # Example 4: Docker registry credentials
  # - name: docker-registry
  #   namespace: default
  #   type: kubernetes.io/dockerconfigjson
  #   scope: strict
  #   output_path: kubernetes/applications/myapp/secrets/docker-registry-sealed.yaml
  #   data:
  #     .dockerconfigjson: |
  #       {
  #         "auths": {
  #           "ghcr.io": {
  #             "username": "myuser",
  #             "password": "ghp_mytoken",
  #             "email": "user@example.com"
  #           }
  #         }
  #       }

  # Example 5: Generic API key
  # - name: api-keys
  #   namespace: default
  #   type: Opaque
  #   scope: namespace-wide  # Can be used by any secret name in the namespace
  #   output_path: kubernetes/applications/myapp/secrets/api-keys-sealed.yaml
  #   data:
  #     stripe-api-key: sk_test_example
  #     sendgrid-api-key: SG.example
  #     cloudflare-token: example-token

# Notes:
# - Secret 'type' can be: Opaque, kubernetes.io/tls, kubernetes.io/dockerconfigjson, etc.
# - Secret 'scope' determines encryption scope:
#   * strict: Bound to specific name and namespace (most secure)
#   * namespace-wide: Can be renamed within the same namespace
#   * cluster-wide: Can be used anywhere in the cluster (least secure)
# - 'output_path' should be relative to the project root
# - All values in 'data' will be base64 encoded automatically by kubectl
